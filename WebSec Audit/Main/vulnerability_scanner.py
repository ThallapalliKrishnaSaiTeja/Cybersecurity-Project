import requests
import re
import time
import json
from typing import List, Dict, Optional, Set
from urllib.parse import urljoin, urlparse, quote
import logging
from dataclasses import dataclass
from enum import Enum

class VulnerabilityType(Enum):
    SQL_INJECTION = "SQL Injection"
    XSS = "Cross-Site Scripting (XSS)"
    CSRF = "Cross-Site Request Forgery"
    BROKEN_AUTH = "Broken Authentication"
    SENSITIVE_DATA = "Sensitive Data Exposure"
    XML_EXTERNAL = "XML External Entities (XXE)"
    BROKEN_ACCESS = "Broken Access Control"
    SECURITY_MISCONFIG = "Security Misconfiguration"
    INSECURE_DESERIALIZATION = "Insecure Deserialization"
    VULNERABLE_COMPONENTS = "Using Components with Known Vulnerabilities"

class Severity(Enum):
    CRITICAL = "Critical"
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"
    INFO = "Informational"

@dataclass
class Vulnerability:
    type: VulnerabilityType
    severity: Severity
    url: str
    parameter: str
    payload: str
    evidence: str
    description: str
    remediation: str
    cwe_id: Optional[str] = None

class VulnerabilityScanner:
    def __init__(self, session: Optional[requests.Session] = None):
        self.session = session or requests.Session()
        self.session.headers.update({
            'User-Agent': 'WebSecurityAuditTool/1.0'
        })
        self.vulnerabilities: List[Vulnerability] = []
        
        # Setup logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
        
        # SQL Injection payloads
        self.sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
            "1' AND SLEEP(5)--"
        ]
        
        # XSS payloads
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "';alert('XSS');//",
            "<svg onload=alert('XSS')>",
            "'\"><script>alert('XSS')</script>"
        ]
        
        # Error patterns for SQL injection detection
        self.sql_error_patterns = [
            r"mysql_fetch_array\(\)",
            r"ORA-\d{5}",
            r"Microsoft.*ODBC.*SQL Server",
            r"PostgreSQL.*ERROR",
            r"Warning.*mysql_.*",
            r"valid MySQL result",
            r"MySqlClient\.",
            r"SQLite/JDBCDriver",
            r"SQLite.Exception",
            r"System.Data.SQLite.SQLiteException"
        ]

    def test_sql_injection(self, url: str, params: Dict[str, str]) -> List[Vulnerability]:
        """Test for SQL injection vulnerabilities"""
        vulnerabilities = []
        
        for param_name, param_value in params.items():
            for payload in self.sql_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = self.session.get(url, params=test_params, timeout=10)
                    
                    # Check for SQL error patterns
                    for pattern in self.sql_error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            vuln = Vulnerability(
                                type=VulnerabilityType.SQL_INJECTION,
                                severity=Severity.HIGH,
                                url=url,
                                parameter=param_name,
                                payload=payload,
                                evidence=f"SQL error pattern found: {pattern}",
                                description="SQL injection vulnerability allows attackers to manipulate database queries",
                                remediation="Use parameterized queries and input validation",
                                cwe_id="CWE-89"
                            )
                            vulnerabilities.append(vuln)
                            self.logger.warning(f"SQL Injection found: {url} - {param_name}")
                            break
                    
                    # Check for time-based SQL injection
                    if "SLEEP" in payload.upper():
                        start_time = time.time()
                        response = self.session.get(url, params=test_params, timeout=15)
                        elapsed_time = time.time() - start_time
                        
                        if elapsed_time > 4:  # If response took longer than expected
                            vuln = Vulnerability(
                                type=VulnerabilityType.SQL_INJECTION,
                                severity=Severity.HIGH,
                                url=url,
                                parameter=param_name,
                                payload=payload,
                                evidence=f"Time delay detected: {elapsed_time:.2f} seconds",
                                description="Time-based SQL injection vulnerability detected",
                                remediation="Use parameterized queries and input validation",
                                cwe_id="CWE-89"
                            )
                            vulnerabilities.append(vuln)
                            
                except requests.RequestException as e:
                    self.logger.error(f"Error testing SQL injection on {url}: {e}")
                    
                time.sleep(0.5)  # Rate limiting
        
        return vulnerabilities

    def test_xss(self, url: str, params: Dict[str, str]) -> List[Vulnerability]:
        """Test for Cross-Site Scripting vulnerabilities"""
        vulnerabilities = []
        
        for param_name, param_value in params.items():
            for payload in self.xss_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                try:
                    response = self.session.get(url, params=test_params, timeout=10)
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        vuln = Vulnerability(
                            type=VulnerabilityType.XSS,
                            severity=Severity.MEDIUM,
                            url=url,
                            parameter=param_name,
                            payload=payload,
                            evidence=f"XSS payload reflected in response",
                            description="Cross-Site Scripting allows execution of malicious scripts",
                            remediation="Implement proper input validation and output encoding",
                            cwe_id="CWE-79"
                        )
                        vulnerabilities.append(vuln)
                        self.logger.warning(f"XSS found: {url} - {param_name}")
                        
                except requests.RequestException as e:
                    self.logger.error(f"Error testing XSS on {url}: {e}")
                    
                time.sleep(0.5)
        
        return vulnerabilities

    def test_form_vulnerabilities(self, form_data: Dict) -> List[Vulnerability]:
        """Test forms for various vulnerabilities"""
        vulnerabilities = []
        
        # Test CSRF protection
        csrf_vuln = self.test_csrf_protection(form_data)
        if csrf_vuln:
            vulnerabilities.append(csrf_vuln)
        
        # Test form inputs for injection vulnerabilities
        if form_data['inputs']:
            test_data = {}
            for input_field in form_data['inputs']:
                if input_field['name']:
                    test_data[input_field['name']] = "test_value"
            
            # Test SQL injection on form
            sql_vulns = self.test_sql_injection_form(form_data, test_data)
            vulnerabilities.extend(sql_vulns)
            
            # Test XSS on form
            xss_vulns = self.test_xss_form(form_data, test_data)
            vulnerabilities.extend(xss_vulns)
        
        return vulnerabilities

    def test_csrf_protection(self, form_data: Dict) -> Optional[Vulnerability]:
        """Test for CSRF protection mechanisms"""
        csrf_tokens = ['csrf_token', 'authenticity_token', '_token', 'csrfmiddlewaretoken']
        
        has_csrf_token = False
        for input_field in form_data['inputs']:
            if input_field['name'].lower() in csrf_tokens:
                has_csrf_token = True
                break
        
        if not has_csrf_token and form_data['method'] == 'POST':
            return Vulnerability(
                type=VulnerabilityType.CSRF,
                severity=Severity.MEDIUM,
                url=form_data['url'],
                parameter="form",
                payload="N/A",
                evidence="No CSRF token found in POST form",
                description="Form lacks CSRF protection, allowing cross-site request forgery attacks",
                remediation="Implement CSRF tokens in all state-changing forms",
                cwe_id="CWE-352"
            )
        
        return None

    def test_sql_injection_form(self, form_data: Dict, test_data: Dict) -> List[Vulnerability]:
        """Test form inputs for SQL injection"""
        vulnerabilities = []
        
        for input_field in form_data['inputs']:
            if input_field['name'] and input_field['type'] not in ['hidden', 'submit']:
                for payload in self.sql_payloads[:3]:  # Use fewer payloads for forms
                    form_data_test = test_data.copy()
                    form_data_test[input_field['name']] = payload
                    
                    try:
                        if form_data['method'] == 'POST':
                            response = self.session.post(form_data['action'], data=form_data_test, timeout=10)
                        else:
                            response = self.session.get(form_data['action'], params=form_data_test, timeout=10)
                        
                        # Check for SQL errors
                        for pattern in self.sql_error_patterns:
                            if re.search(pattern, response.text, re.IGNORECASE):
                                vuln = Vulnerability(
                                    type=VulnerabilityType.SQL_INJECTION,
                                    severity=Severity.HIGH,
                                    url=form_data['action'],
                                    parameter=input_field['name'],
                                    payload=payload,
                                    evidence=f"SQL error in form submission: {pattern}",
                                    description="SQL injection in form input field",
                                    remediation="Use parameterized queries for form processing",
                                    cwe_id="CWE-89"
                                )
                                vulnerabilities.append(vuln)
                                break
                                
                    except requests.RequestException as e:
                        self.logger.error(f"Error testing form SQL injection: {e}")
                    
                    time.sleep(0.5)
        
        return vulnerabilities

    def test_xss_form(self, form_data: Dict, test_data: Dict) -> List[Vulnerability]:
        """Test form inputs for XSS"""
        vulnerabilities = []
        
        for input_field in form_data['inputs']:
            if input_field['name'] and input_field['type'] not in ['hidden', 'submit', 'password']:
                for payload in self.xss_payloads[:3]:
                    form_data_test = test_data.copy()
                    form_data_test[input_field['name']] = payload
                    
                    try:
                        if form_data['method'] == 'POST':
                            response = self.session.post(form_data['action'], data=form_data_test, timeout=10)
                        else:
                            response = self.session.get(form_data['action'], params=form_data_test, timeout=10)
                        
                        if payload in response.text:
                            vuln = Vulnerability(
                                type=VulnerabilityType.XSS,
                                severity=Severity.MEDIUM,
                                url=form_data['action'],
                                parameter=input_field['name'],
                                payload=payload,
                                evidence="XSS payload reflected in form response",
                                description="Cross-Site Scripting in form input field",
                                remediation="Implement input validation and output encoding for form fields",
                                cwe_id="CWE-79"
                            )
                            vulnerabilities.append(vuln)
                            
                    except requests.RequestException as e:
                        self.logger.error(f"Error testing form XSS: {e}")
                    
                    time.sleep(0.5)
        
        return vulnerabilities

    def test_security_headers(self, url: str) -> List[Vulnerability]:
        """Test for missing security headers"""
        vulnerabilities = []
        
        try:
            response = self.session.get(url, timeout=10)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options header allows clickjacking attacks',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options allows MIME type sniffing',
                'X-XSS-Protection': 'Missing X-XSS-Protection header',
                'Strict-Transport-Security': 'Missing HSTS header allows protocol downgrade attacks',
                'Content-Security-Policy': 'Missing CSP header allows various injection attacks'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    vuln = Vulnerability(
                        type=VulnerabilityType.SECURITY_MISCONFIG,
                        severity=Severity.LOW,
                        url=url,
                        parameter="HTTP Headers",
                        payload="N/A",
                        evidence=f"Missing security header: {header}",
                        description=description,
                        remediation=f"Add {header} header to HTTP responses",
                        cwe_id="CWE-16"
                    )
                    vulnerabilities.append(vuln)
            
        except requests.RequestException as e:
            self.logger.error(f"Error testing security headers: {e}")
        
        return vulnerabilities

    def scan_endpoint(self, url: str, params: Optional[Dict[str, str]] = None) -> List[Vulnerability]:
        """Scan a single endpoint for vulnerabilities"""
        vulnerabilities = []
        
        if params:
            # Test URL parameters
            sql_vulns = self.test_sql_injection(url, params)
            vulnerabilities.extend(sql_vulns)
            
            xss_vulns = self.test_xss(url, params)
            vulnerabilities.extend(xss_vulns)
        
        # Test security headers
        header_vulns = self.test_security_headers(url)
        vulnerabilities.extend(header_vulns)
        
        return vulnerabilities

    def scan_forms(self, forms: List[Dict]) -> List[Vulnerability]:
        """Scan all discovered forms"""
        vulnerabilities = []
        
        for form in forms:
            form_vulns = self.test_form_vulnerabilities(form)
            vulnerabilities.extend(form_vulns)
        
        return vulnerabilities

    def get_vulnerability_summary(self) -> Dict:
        """Get summary of found vulnerabilities"""
        summary = {
            'total': len(self.vulnerabilities),
            'by_severity': {},
            'by_type': {}
        }
        
        for vuln in self.vulnerabilities:
            # Count by severity
            severity = vuln.severity.value
            summary['by_severity'][severity] = summary['by_severity'].get(severity, 0) + 1
            
            # Count by type
            vuln_type = vuln.type.value
            summary['by_type'][vuln_type] = summary['by_type'].get(vuln_type, 0) + 1
        
        return summary

if __name__ == "__main__":
    # Example usage
    scanner = VulnerabilityScanner()
    test_params = {'id': '1', 'search': 'test'}
    vulns = scanner.scan_endpoint("http://example.com/search", test_params)
    print(f"Found {len(vulns)} vulnerabilities")
